import sqlite3
import subprocess
import os
import datetime
from flask import Flask, request, render_template, redirect, url_for, session, abort

app = Flask(__name__)
app.secret_key = 'super_secret_key'

# NGFW: In-memory list of blocked IPs
BLOCKED_IPS = {}

# NGFW: Function to check if IP is blocked
def is_ip_blocked(ip):
    if ip in BLOCKED_IPS:
        # Check if ban time (1 minute) has passed
        if datetime.datetime.now() < BLOCKED_IPS[ip]:
            return True
        else:
            del BLOCKED_IPS[ip] # Unban after time expires
    return False

# NGFW: Function to ban an IP
def block_ip(ip, reason):
    # Ban for 2 minutes
    BLOCKED_IPS[ip] = datetime.datetime.now() + datetime.timedelta(minutes=2)
    print(f"[NGFW] ALERT: Blocking IP {ip} due to {reason}")

def init_db():
    conn = sqlite3.connect('astra.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')
    c.execute('''CREATE TABLE IF NOT EXISTS alerts (id INTEGER PRIMARY KEY, message TEXT)''')
    try:
        c.execute("INSERT INTO users (username, password) VALUES ('admin', 'password123')")
        conn.commit()
    except:
        pass
    conn.close()

# MIDDLEWARE: The "Firewall" Layer
@app.before_request
def firewall_check():
    client_ip = request.remote_addr
    if is_ip_blocked(client_ip):
        return render_template('firewall_block.html', ip=client_ip, expire=BLOCKED_IPS[client_ip])

@app.route('/', methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        client_ip = request.remote_addr

        # NGFW DETECTION: SQL Injection Pattern
        if "'" in username or "OR" in username.upper() or "=" in username:
            block_ip(client_ip, "SQL Injection Attempt")
            return render_template('firewall_block.html', ip=client_ip, expire=BLOCKED_IPS[client_ip])

        conn = sqlite3.connect('astra.db')
        c = conn.cursor()
        # Vulnerable Query
        query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
        
        try:
            c.execute(query)
            user = c.fetchone()
            conn.close()
            if user:
                session['user'] = user[1]
                return redirect(url_for('dashboard'))
            else:
                error = "Invalid Credentials"
        except Exception as e:
            error = f"Database Error: {e}"
            
    return render_template('login.html', error=error)

@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
    if 'user' not in session:
        return redirect(url_for('login'))
    
    output_message = ""
    client_ip = request.remote_addr
    
    if request.method == 'POST':
        alert_text = request.form['alert_text']
        
        # NGFW DETECTION: XSS Pattern
        if "<script>" in alert_text or "<img" in alert_text:
            # We log it but don't block immediately to allow you to demo the XSS first.
            # To simulate Strict NGFW, uncomment the next line:
            # block_ip(client_ip, "XSS Attack Attempt")
            pass

        # NGFW DETECTION: Buffer Overflow (Length Check)
        if len(alert_text) > 100:
             block_ip(client_ip, "Buffer Overflow / DoS Attempt")
             return render_template('firewall_block.html', ip=client_ip, expire=BLOCKED_IPS[client_ip])

        # 1. DATABASE INSERT (Vulnerable to XSS)
        conn = sqlite3.connect('astra.db')
        c = conn.cursor()
        c.execute(f"INSERT INTO alerts (message) VALUES ('{alert_text}')")
        conn.commit()
        conn.close()

        # 2. C-BACKEND TRIGGER (Vulnerable to Overflow)
        binary_path = os.path.abspath("./vuln_backend")
        if os.path.exists(binary_path):
            try:
                result = subprocess.run([binary_path, alert_text], capture_output=True, text=True)
                if result.returncode < 0: 
                    output_message = f"CRITICAL FAILURE: Backend Crashed! (Signal {result.returncode})"
                else:
                    output_message = f"Backend processed: {result.stdout}"
            except Exception:
                pass

    conn = sqlite3.connect('astra.db')
    c = conn.cursor()
    c.execute("SELECT message FROM alerts")
    alerts = c.fetchall()
    conn.close()

    # Data for the HEATMAP
    # Simulating risks based on open ports/services we "know" about
    risk_data = [
        {'node': 'ASTRA Web App', 'cve': 'CVE-2021-XSS', 'risk': 'Critical'},
        {'node': 'Docker DB (3306)', 'cve': 'Weak Auth', 'risk': 'High'},
        {'node': 'File Srv (2121)', 'cve': 'Anonymous Login', 'risk': 'Medium'},
        {'node': 'Client PC', 'cve': 'None', 'risk': 'Low'}
    ]

    return render_template('dashboard.html', user=session['user'], alerts=alerts, output=output_message, risks=risk_data)

@app.route('/logout')
def logout():
    session.pop('user', None)
    return redirect(url_for('login'))

if __name__ == '__main__':
    init_db()
    app.run(host='0.0.0.0', port=5000, debug=True)
